---
title:"seatrackGLS tutorial"
output:
  html_document:
  date:"2025-11-19"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, )
```



| *contact re. GLS data processing: [vegard.brathen\@nina.no](mailto:vegard.brathen@nina.no){.email}*

This is a tutorial made for SEATRACK for how to process data from geolocators with the seatrackGLS package.

This tutorial practice the use of seatrackGLS for the SEATRACK project and within, conduct sun angle calibrations to compensate for differences in light sensitivity between geolocator sensors. Sun angle calibrations is important to achieve realistic latitude estimates.  

In this tutorial, you will practice processing data collected from Black-legged kittiwakes breeding at Halten in Norway.

For the sake of practicing a common scenario in SEATRACK, we here have four individuals processed beforehand and now you have gotten data from four more to process. 
At the same time, data from the previously four processed birds should be reanalyzed because seatrackGLS has been updated since last time. 

For the four 'new' individuals, data has to be calibrated, meaning a preliminary run of seatrackGLS in order to produce calibration plots. Calibration plots are then assessed by the analyser to find the sun angles (light sensitivity) that produce the most realistic latitudes. For the four 'old' individuals, data has been calibrated already, and calibration values can be reused. No prelinary run of seatrackGLS required.

At last, seatrackGLS is  run a final time on all the data and the positional data is then ready to be used and imported into the SEATRACK database.   

### Prepare workspace
```{r setup}
library(seatrackRgls)
library(GeoLocTools)
```

### Specify colony and species
The script is set up to run with data from one colony and one species at a time.
- The user specify which colony and which species

```{r echo=TRUE, results='hide', message = FALSE}
Colony <- "Halten"
Species <- "Black-legged kittiwake"
Analyzer <- "test"
```

### Set up directories
A series of directories needs to be specified.
Except for this tutorial, this setup imports raw geolocator data from, and exports final processed data to, centralized folders on the SEATRACK OneDrive ('lux_dir' and 'data_files_dir'). 

Other imports and exports (metadata ('string_dir'), maps ('save_maps'), filtering plots ('save_filter_plots') and calibration plots ('save_sun_plots')) require directories to specific species-colony sub-folders on OneDrive. For example: "C:\(...)\Benjamin Merkel - SEATRACK - shared\Locations\Svalbard\Bjørnøya\processed\Little auk"

The user must therefore make sure to check that the species-specific folders are set up right and that the respective directories works 

```{r echo=TRUE,results='hide',message = FALSE}
# EXPORT PLOT DIRECTORY
# species-colony specific
string_dir<-"C:/Users/vegard.brathen/Norsk Polarinstitutt/Benjamin Merkel - SEATRACK - shared/Database/Imports_Positions_seatrackGLS/Scripts/practise_seatrackGLS/"
save_sun_plots<-paste(string_dir,"sun_calib/",sep="")
save_maps<-paste(string_dir,"maps/",sep="")
save_filter_plots<-paste(string_dir,"plots/",sep="")

# LUX_DIR - IMPORT DIRECTORY
#centralized
lux_dir<-"C:/Users/vegard.brathen/Norsk Polarinstitutt/Benjamin Merkel - SEATRACK - shared/Database/Imports_Logger data/Raw logger data/ALL/"
# EXPORT PROCESSED TABULAR DATA FILES
data_files_dir<-"C:/Users/vegard.brathen/Norsk Polarinstitutt/Benjamin Merkel - SEATRACK - shared/Database/Imports_Positions_seatrackGLS/Scripts/practise_seatrackGLS/data_files/"

```


### Load packages
seatrackGLS is at the moment a 'local' R package. Meaning it won't work in the same way as other R packages.
In order to make it work, package 'devtools' must be installed and the location of the package must be chosen as the 'working directory' before installing or requiring seatrackGLS. Afterwards, it will work as any other R package.

seatrackGLS relies on R functions from GeoLight, which is another R package made for geolocator processing. It is convenient to install the 'GeoLocTools', which is a compilation on packages that are used to process geolocator data - like FlightR, probGLS, SGAT, GeoLight etc.

### Import metadata
seatrackGLS rquire supporting metadata about the logger used and the instrumented individual in order to work.

Metadata can be extracted from the SEATRACK database and stored on the species-colony specific folder as an excel file:
```{r echo=TRUE,results='hide',message = FALSE}
#---------------------- load metadata ---------------
library(openxlsx)#install.packages("openxlsx")
connectSeatrack(Username = "testreader", Password = "testreader",
                host = "seatrack.nina.no")
metadata_db<-get_seatrack_metadata(Colony=Colony,Species=Species,Analyzer=Analyzer)
```

The analyser will add  calibration values to the metadata file. 
If rerunning seatrackGLS on already calibrated geolocator data, historic seatrack metadata should be available for import.
Historic metadata should be updated in order to fit the latest information in the database.

The historic metadata contains calibration values, and should be kept organized on the OneDrive (In 2025: under OneDrive->'Locations'->Country->Colony->'processed'->species)


```{r echo=TRUE,results='hide',message = FALSE}
#---------------------- load and historic metadata ---------------
library(openxlsx)#install.packages("openxlsx")
connectSeatrack(Username = "testreader", Password = "testreader",
                host = "seatrack.nina.no")
metadata <- as.data.frame(read_excel(paste(string_dir,"metadata.xlsx",sep="")))

if(length(metadata)>0){
metadata$date_retrieved<-date_conversion(metadata$date_retrieved)
metadata$file_name<-paste(metadata$logger_id,"_",year(metadata$date_retrieved),"_",metadata$logger_model,sep="")
metadata$file_name[metadata$logger_producer%in%"Migrate Technology"]<-paste(metadata$file_name[metadata$logger_producer%in%"Migrate Technology"],".lux",sep="")
metadata$file_name[metadata$logger_producer%in%c("BAS","Biotrack","Lotek")]<-paste(metadata$file_name[metadata$logger_producer%in%c("BAS","Biotrack","Lotek")],".lig",sep="")}

#---------------------- update historic metadata ---------------
connectSeatrack(Username = "testreader", Password = "testreader",
                host = "seatrack.nina.no")
medata<-update_seatrack_metadata(df=metadata,Colony=Colony,Species=Species,Analyzer=Analyzer)
```

Merge historic and new metadata into one file and save as an excel sheet:

```{r echo=TRUE,results='hide',message = FALSE}
#---------------------- merge and save metadata ---------------
#1. make a common column for historic excel metadata and metadata from database
metadata_db$id_column<-paste(metadata_db$logger_id,year(metadata_db$date_deployed),year(metadata_db$date_retrieved),sep="_")
metadata$id_column<-paste(metadata$logger_id,year(metadata$date_deployed),year(metadata$date_retrieved),sep="_")

#2. rbind rows for newly retrieved loggers to the historic excel metadata
metadata_db<-metadata_db[!(metadata_db$id_column%in%metadata$id_column),]
#new columns added:
metadata<-rbind(metadata,metadata_db)
metadata$id_column<-NULL

# Save the data frame to Excel with UTF-8 encoding (this is the default behavior)
write.xlsx(metadata, paste0(string_dir,"metadata.xlsx"))
```


### Filter SEATRACK filter settings
Species-specific SEATRACK settings for used for the various functions within seatrackGKLS can be extracted from the seatrackGLS package. 

- The user are free to test other settings in this tutorial
- when later working with SEATRACK data, there can be exceptions made

```{r echo=TRUE,results='hide',message = FALSE}
#---------------------- load SEATRACK filter settings ---------------
seatrack_settings <- read.csv(system.file("seatrack_settings", "seatrack_settings.csv", package = "seatrackGLS"),sep=";")
#literature cited needs to be updated!
```

Filter settings:
-   *luxfile* = required, specify how to read in light data 
-   *save_sun_plots.dir* = where to save plots for sun angle calibrations. If NA or NULL, no plots are produced 
-   *save_filter_plots.dir* = where to save plots showing filter effects. If NA or NULL, no plots are produced 
-   *speed* = required, flight speed (km/h) 
-   *boundary.box* = required, distribution limits (c(lonW,lonE,latS,latN)) PS! lons as 0-360 deg if crossing the 180 meridian (otherwise -180 to 180) 
-   *coast_to_land* = required, kilometers individual is allowed to fly inland. Inf = infinite. 
-   *coast_to_sea* = required, kilometers individual is allowed to fly offshore Inf = infinite. 
-   *loess_filter_k* = required, number of interquartile ranges for identifying and filtering twilights 
-   *months_breeding* = approximate of months with regular presence at breeding location. Enhance filter performance during breeding 
-   *man_equinox_periods* = restrict equinox periods manually by day and month.
-   *aut_equinox_periods* = define equinox period based on approx. latitudes before and after equinox.Overrides 'man_equinox_periods' 
-   *midnightsun_removal* = helps removing erroneous positions while breeding under the midnight sun 
-   *add_summer_pos* = extra positions estimated using a higher threshold at each side of hemispheric summer
-   *add_winter_pos* = extra positions estimated using a minimum threshold value during hemispheric winter
-   *noonfilter* = twilight filtered based on corresponding noon/midnight 
-   *daylengthfilter* = twilight filtered based on corresponding day length/night length
-   *split_years* = for convenience, tracks can be split up in yearly sections (e.g. summer 2015 to summer 2016)
-   *year_tracked* = for convenience, corresponding metadata gets added and linked by yearly sections
-   *sun_angle_start* = assigned during sun angle calibrations. Default is -3.5 (based on SEATRACK average) 
-   *sun_angle_end* = assigned during sun angle calibrations if drift in sun angles. Default is'sun_angle_start'
-   *light_threshold* = required, which light-level defines a twilight event (dawn and dusk) 
-   *logger_id* = for convenience, logger id can be added to the positional data set 
-   *logger_model* = for convenience, logger model can be added to the positional data set 
-   *ring_number* = for convenience, bird id can be added to the positional data set 
-   *species* = for convenience, species name can be added to the positional data set 
-   *colony* = for convenience, breeding location can be added as name to the positional data set 
-   *col_lon* = required, breeding longitude is used by several functions 
-   *col_lat* = required, breeding latitude is used by several functions 
-   *date_deployed* = required, limit the light-level data to time on the bird 
-   *date_retrieved* = required, limit the light-level data to time on the bird 
-   *age_deployed* = for convenience, birds' age can be added to the positional data set


### Load raw geolocator data
Raw logger data should be possible to load from to sources: centrally on OneDrive, or centrally from the file archive in the database.
However, the database function does not seem to work at the moment.

When loading data, on should be sure that files listed in the metadata is matched by an actually file. 

```{r echo=TRUE,results='hide',message = FALSE}
#---------------------- load raw data ---------------

#load raw data from a local file archive
files<-list.files(lux_dir)

#does files match rows in metadata?
match(metadata$file_name,files)
#If no NA's - ok
#If NA's - check why


#from db file archive (in development)
#download to pc
#connectSeatrack(Username = "testreader", Password = "testreader",
#                host = "seatrack.nina.no")
#downloadFiles(files = metadata$file_name, destFolder = "temp")
```

### select data to run with seatrackGLS
If there is uncalibrated logger data, code string below selects only that data to run with seatrackGLS.
If all data has been calibrated, it selects all data

```{r echo=TRUE,results='hide',message = FALSE}
#---------------------- select data to run with seatrackGLS ---------------
if(nrow(metadata[is.na(metadata$sun_angle_start),])>0)metadata<-metadata[is.na(metadata$sun_angle_start),]
nrow(metadata)
```

### run seatrackGLS and save processed data
In a loop, one row of the metadata subset above is processed at a time. 
- The matched logger data gets imported
- Logger data gets limited to the time-span each metadata row represents
- Twilight events gets estimated and filtered
- Positions gets calculated from estimated twilight events + calibrated sun angles (default is sun being 3.5 below the horizon) 
- Positions gets filtered

```{r echo=TRUE,results='hide',message = FALSE}
#---------------------- run seatrackGLS ---------------
i=1
for(i in 1:nrow(metadata)){
  tryCatch({
    settings<-seatrack_settings[seatrack_settings$species%in%metadata$species[i],]
    #---------------------- run seatrackGLS ---------------
  # see ?seatrackGLS for details
  locations <- seatrackGLS(luxfile                     = paste(lux_dir, metadata$file_name[i],sep=""),
                           save_sun_plots.dir          = save_sun_plots, #if NULL, no plot saved
                           save_filter_plots.dir       = save_filter_plots, #if NULL, no plot saved
                           speed                       = settings$speed,
                           boundary.box                = eval(parse(text = settings$boundary.box)),   
                           coast_to_land               = settings$coast_to_land,
                           coast_to_sea                = settings$coast_to_sea,
                           loess_filter_k              = settings$loess_filter_k,                 
                           months_breeding             = eval(parse(text = settings$months_breeding)), 
                           man_equinox_periods         = c("02-22","04-01","09-12","10-18"),
                           aut_equinox_periods         = TRUE,
                           midnightsun_removal         = TRUE, 
                           add_summer_pos              = TRUE,
			                     add_winter_pos              = TRUE,
                           noonfilter                  = TRUE,
                           daylengthfilter             = TRUE,
                           split_years                 = c("05-31","06-01"),
                           year_tracked                = metadata$year_tracked[i],
                           sun_angle_start             = metadata$sun_angle_start[i],
                           sun_angle_end               = metadata$sun_angle_end[i],
                           light_threshold             = metadata$light_threshold[i],
                           logger_id                   = metadata$logger_id[i],
                           logger_model                = metadata$logger_model[i],
                           ring_number                 = metadata$ring_number[i],
                           species                     = metadata$species[i],
                           colony                      = metadata$colony[i], 
                           col_lon                     = metadata$col_lon[i],
                           col_lat                     = metadata$col_lat[i],
                           date_deployed               = as.Date(metadata$date_deployed[i]),
                           date_retrieved              = as.Date(metadata$date_retrieved[i]),
                           age_deployed                = metadata$age_deployed[i])




  one_track<-locations$tracks
  filter_one_track<-locations$`number of datapoints removed or retained`

  one_track$analyzer<-metadata$analyzer[i]
  one_track$data_responsible<-metadata$data_responsible[i]
  one_track$posdata_file<-metadata$posdata_file[i]


  if(paste(metadata$logger_id[1],metadata$logger_model[1],metadata$year_tracked[1], sep="_") == paste(one_track$logger_id[1],one_track$logger_model[1],one_track$year_tracked[1], sep="_")){
    all_tracks<-one_track
    all_filtering<-filter_one_track}
  if(paste(metadata$logger_id[1],metadata$logger_model[1],metadata$year_tracked[1], sep="_") != paste(one_track$logger_id[1],one_track$logger_model[1],one_track$year_tracked[1], sep="_")){
    all_tracks <- rbind(all_tracks,one_track)
    all_filtering<-rbind(all_filtering,filter_one_track)}

  #plot_a_map(one_track)

  write.table(all_tracks,paste(data_files_dir,metadata$posdata_file[1],".txt", sep=""),quote=FALSE,col.names = TRUE,row.names=FALSE, sep="\t", append = FALSE)
  write.table(all_filtering,paste(data_files_dir,"filtering_",metadata$posdata_file[1],".txt", sep=""),quote=FALSE,col.names = TRUE,row.names=FALSE, sep="\t", append = FALSE)

  }, error=function(e){cat("ERROR :",conditionMessage(e), "\n")})
}
```

### Map positions

```{r echo=TRUE}
all_tracks<-read.table(paste(data_files_dir,metadata$posdata_file[1],".txt", sep=""), sep="\t",header = T,quote="\"")
plot_a_map(all_tracks[all_tracks$ring_number%in%unique(all_tracks$ring_number)[1],])
```

### Outputs:
- *A positional data set*
```{r echo=TRUE}
all_tracks<-read.table(paste(data_files_dir,metadata$posdata_file[1],".txt", sep=""), sep="\t",header = T,quote="\"")
colnames(all_tracks)
```

-   Date_time = date and time of the calculated position in GMT (DD.MM.YYYY HH:MM)\
-   logger_id = specific logger ID for each GLS logger (e.g N032).\
-   logger_model = GLS logger model (e.g c65, mk4083 etc)
-   year_tracked = 'year_tracked' specify the tracking period from one breeding<br/>season to the next (e.g.'2013_14').
-   session_id = unique for each time a logger was deployed
-   individ_id = unique for each individual
-   year_deployed = year of deployment
-   year_retrieved = year of retrieval
-   species = english name of the species (e.g 'Black-legged kittiwake')
-   colony = name of the colony the logger was deployed and retrieved in.<br/>Colony name can often cover multiple breeding locations when in close proximity.
-   col_lon = longitude of the colony.\
-   col_lat = latitude of the colony.
-   lon_raw = longitude calculated from time (GMT) of noon or midnight and date
-   lat_raw = latitude calculated from the length of day or night and date.
-   lon and lat= first averaging consecutive noon-midnight or midnight-noon<br/>lon_raws and lat_raws, then a two point moving average on subsequent coordinates using spherical trigonometry.
-   eqfilter = this filter identifies fixed periods where the latitudes are<br/>assumed to be unreliable during equinox (1 = reliable/outside fixed equinox period, 0 = unreliable/inside equinox).
-   tfirst = time of first sun event (DD.MM.YYYY HH:MM) used for calculating<br/>positions
-   tsecond = time of second sun event (DD.MM.YYYY HH:MM) used for calculating<br/>positions
-   twl_type = identify whether 'tfirst' is sunrise (1) or sunset (2)
-   sun = the suns angle to the horizon used to calculated the positions from<br/>twilight events.
-   light_threshold = selected threshold that defines a sunset/sunrise
-   script_version = script version
-   analyzer = name of person that run scripts and perform the sun elevation<br/>angle calibration
-   data_responsible = name of data responsible


- *A file with number of removed twilight events or positions from each filtering step*
```{r echo=TRUE}
all_filtering<-read.table(paste(data_files_dir,"filtering_",metadata$posdata_file[1],".txt", sep=""), sep="\t",header = T,quote="\"")
head(all_filtering)
```

- *Plots from filtering*
```{r, echo=FALSE, out.width='70%'}
knitr::include_graphics(paste0(save_filter_plots,"13054_mk13_2010_11speed_bbox_angleanddist_loess_end.tiff"))
```
- *Plots for calibration*
```{r, echo=FALSE, out.width='70%'}
#library(magick)
#img <- image_read(paste0(save_sun_plots,"13054_mk13_2010_11lat vs time.tiff"))
#image_write(img, path = paste0(save_sun_plots,"13054_mk13_2010_11lat vs time"), format = "png")
knitr::include_graphics(paste0(save_sun_plots,"13054_mk13_2010_11lat vs time.tiff"))

#img <- image_read(paste0(save_sun_plots,"13054_mk13_2010_11sun maps aut_.tiff"))
#image_write(img, path = paste0(save_sun_plots,"13054_mk13_2010_11sun maps aut_"), format = "png")
knitr::include_graphics(paste0(save_sun_plots,"13054_mk13_2010_11sun maps aut_.tiff"))
```
